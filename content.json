{"pages":[{"title":"","text":"Intro.Hey there, I‚Äôm Dohun, Growth Marketer turned Software Developer.Currently living in Singapore üá∏üá¨. Github LinkedIn Email Projects ToDo List Simple todo-list built with 2 different frameworks - Node.js vs React Merlabot Merlabot is a Singapore Travel bot for Korean tourists. Automating Instagram Likes Programme that likes top 3 recent post of hashtags provided img.is-rounded { border-radius: 50%; } .buttons { width: 100%; display: flex; } .buttons a.button { flex-grow: 1; } a.button.is-linkedin { background-color: #0077B5; border-color: #0077B5; color: #FFF; } @media screen and (max-width: 720px) { .buttons a.button { width: 100%; margin-right: 0; } } .project-links { margin-bottom: 16px; } /* DEMO-SPECIFIC STYLES */ .wrapper { display: flex; justify-content: center; } .typewriter h1 span{ color: #000000; font-size: 33px; font-family: inherit; overflow: hidden; /* Ensures the content is not revealed until the animation */ border-right: .15em solid orange; /* The typwriter cursor */ white-space: nowrap; /* Keeps the content on a single line */ margin: 0 auto; /* Gives that scrolling effect as the typing happens */ letter-spacing: 0em; /* Adjust as needed */ animation: typing 2s steps(30, end), blink-caret .5s step-end; } /* The typing effect */ @keyframes typing { from { width: 0 } to { width: 100% } } /* The typewriter cursor effect */ @keyframes blink-caret { from, to { border-color: transparent } 50% { border-color: orange } } var TxtType = function(el, toRotate, period) { this.toRotate = toRotate; this.el = el; this.loopNum = 0; this.period = parseInt(period, 10) || 2000; this.txt = ''; this.tick(); this.isDeleting = false; }; TxtType.prototype.tick = function() { var i = this.loopNum % this.toRotate.length; var fullTxt = this.toRotate[i]; if (this.isDeleting) { this.txt = fullTxt.substring(0, this.txt.length - 1); } else { this.txt = fullTxt.substring(0, this.txt.length + 1); } this.el.innerHTML = ''+this.txt+''; var that = this; var delta = 200 - Math.random() * 100; if (this.isDeleting) { delta /= 2; } if (!this.isDeleting && this.txt === fullTxt) { delta = this.period; this.isDeleting = true; } else if (this.isDeleting && this.txt === '') { this.isDeleting = false; this.loopNum++; delta = 500; } setTimeout(function() { that.tick(); }, delta); }; window.onload = function() { var elements = document.getElementsByClassName('typewrite'); for (var i=0; i","link":"/index.html"}],"posts":[{"title":"TIL-191002","text":"Today I Learned Attempted Fizz Buzz on Leetcode. It was a fairly easy and straight-forward array problem. Solved through forloop. Attempted Deleting A Node In a Singly Linked List on Leetcode. Seems like I‚Äôm still not completely sound with the linked list concept. Referred to guide and discussion for solution. Read up on Prototype concept : Reference Summary Prototype object of the constructor function is shared among all the objects created using the constructor function. Problem with the constructor function: Every object has its own instance of the function Problem with the prototype: Modifying a property using one object reflects the other object also Learned new DOM functions insertRow, insertCell","link":"/2019/10/02/TIL-191002/"},{"title":"Delete Node In a Singly Linked List","text":"ProblemWrite a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list ‚Äì head = [4,5,1,9]Example 1: 12Input: head = [4,5,1,9], node = 5Output: [4,1,9] Example 2: 12Input: head = [4,5,1,9], node = 1Output: [4,5,9] Note: The linked list will have at least two elements. All of the nodes‚Äô values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. Approach Delete the first node Assign next node to head 1234var deleteNode = function(node) { node.val = node.next.val node.next = node.next.next} Take Away Deleting the Linked List Question Source - Leetcode","link":"/2019/10/02/delete-node-in-singly-linked-list/"},{"title":"Fizz Buzz","text":"ProblemWrite a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output ‚ÄúFizz‚Äù instead of the number and for the multiples of five output ‚ÄúBuzz‚Äù. For numbers which are multiples of both three and five output ‚ÄúFizzBuzz‚Äù. Example: 123n = 15,return[&quot;1&quot;,&quot;2&quot;,&quot;Fizz&quot;,&quot;4&quot;,&quot;Buzz&quot;,&quot;Fizz&quot;,&quot;7&quot;,&quot;8&quot;,&quot;Fizz&quot;,&quot;Buzz&quot;,&quot;11&quot;,&quot;Fizz&quot;,&quot;13&quot;,&quot;14&quot;,&quot;FizzBuzz&quot;] Approach Iterative approach Using modulo (%) to filter out 3 &amp; 5 To filter 15, 3 &amp; 5 must be excluded first Numbers must be turned to integer 123456789101112131415var fizzBuzz = function(n) { let ans = [] for (i = 1; i &lt;= n; i++) { if (i % 3 == 0 &amp;&amp; i % 5 !== 0) { ans.push(\"Fizz\") } else if (i % 5 == 0 &amp;&amp; i % 3 !== 0) { ans.push(\"Buzz\") } else if (i % 15 == 0) { ans.push(\"FizzBuzz\") } else { ans.push(i.toString()) } } return ans} Question Source - Leetcode","link":"/2019/10/02/fizz-buzz/"},{"title":"TIL-191003","text":"Today I Learned Finished Creating ToDo using Axios &amp; DOM JavaScript Why Use Axios &amp; DOM JavaScript? Using NodeJS &amp; ejs required continuous redirecting and refreshing web pages to update data. It is therefore considered relatively slower. By using DOM JavaScript and Axios, it makes use of Axios to call RESTful API from Node server to update data frontend on DOM without a need to refresh web pages. DOM JS function calls can be called to call updated data. How Does It Work? Call fetchTask to GET ToDo tasks and call appendDOM. Every time appendDOM is called, it resets the table &amp; add rows using data called from fetchTask by calling createTable. createTable adds checkbox in the 1st cell, task title in the 2nd cell and delete button in the 3rd cell. Checkbox onclick calls updateTask function that in turn PUT ToDo tasks by calling RESTful API and updating is_done as true or false respectively Delete button calls deleteTask function that DELETE ToDo tasks. To add new tasks, form is submitted and the data is passed over to createTask function. Note: form to be reset after submission createTask POST new tasks into the RESTful API.Note: Everytime there is an update in the state of the tasks data, fetchTaskis called to keep the tasks data updated","link":"/2019/10/03/TIL-191003/"},{"title":"TIL-191004","text":"Today I Learned Attempted Valid Anagram on Leetcode. First attempt was Brute Force solution using Array object methods - push &amp; splice. Improved attempt made use of key value pair object. When passing data to RESTful API using Axios, there is a difference ways of sending the data.In below case, id is being passed over as path parameter. 1234axios .post(`/api/tasks/${id}`) .then() .catch(err) While in this case, is_done is being passed over as request body parameter in JSON format. 123456axios .post(`/apid/tasks/${id}`, { is_done: is_done }) .then() .catch(err) More on REST API parameters best practices","link":"/2019/10/04/TIL-191004/"},{"title":"Valid Anagram","text":"ProblemGiven two strings s and t , write a function to determine if t is an anagram of s. Example 1: 12Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true Example 2: 12Input: s = &quot;rat&quot;, t = &quot;car&quot;Output: false Note:You may assume the string contains only lowercase alphabets. Approach1st Attempt - Brute Force123456789101112131415161718var isAnagram = function(s, t) { //corner case if (s.length !== t.length) return false if (s.length == 0) return true // Create Array let ans = [] for (i = 0; i &lt; s.length; i++) { ans.push(s[i]) } // Check through Array &amp; Delete if present for (j = 0; j &lt; t.length; j++) { let n = ans.indexOf(t[j]) if (n &gt; -1) { ans.splice(n, 1) } } return ans.length == 0 ? true : false} 2nd Attempt - hashmap with alphabet &amp; its count (More Efficient)123456789101112131415var isAnagram = function(s, t) { if (s.length !== t.length) return false const map = {} for (let i = 0; i &lt; s.length; i++) { map[s[i]] ? map[s[i]]++ : (map[s[i]] = 1) } for (let i = 0; i &lt; t.length; i++) { if (map[t[i]]) map[t[i]]-- else return false } return true} Take Away &amp; Review Did not take into account that same alphabet can be stacked. In the 2nd Attempt, it‚Äôs as easy as increasing the alphabet value in the map at ‚Äòs‚Äô loop and decreasing the alphabet value in the map at ‚Äòt‚Äô loop. If the map is empty at the end of the function, it is true. Question Source","link":"/2019/10/06/valid-anagram/"},{"title":"Convert Sorted Array To Binary Search Tree","text":"ProblemGiven an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: 123456789Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5 Attempt Tree problems can usually be solved by recursive / iterative approach. Since the BST takes lower number to the left of a node &amp; higher number to the right, the number on the middle should be the most parent node. Recursive Solution 123456789101112var sortedArrayToBST = function(nums) { //Corner case to break out of recursive calls if (!nums.length) return null //Declarations let n = nums.length let mid = Math.floor(nums.length / 2) let node = new TreeNode(nums[mid]) //Recursive calls node.left = sortedArrayToBST(nums.slice(0, mid)) //tasks the lower value node.right = sortedArrayToBST(nums.slice(mid + 1)) //tasks the higher value return node} Question Source - Leetcode","link":"/2019/10/07/convert-sorted-array-to-binary-search-tree/"},{"title":"Best Time To Buy and Sell Stock II","text":"ProblemSay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 12345Input: [7,1,5,3,6,4]Output: 7Explanation:- Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.- Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Example 2: 123456Input: [1,2,3,4,5]Output: 4Explanation:- Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.- Note that you cannot buy on day 1, buy on day 2 and sell them later, as you areengaging multiple transactions at the same time. You must sell before buying again. Attempt Could not come up with the correct answer myself. Solution is based on the idea that the global maximum profit would be the sum of local maximum profit. Reference If the price next day prices[i+1]) is higher than price today prices[i], accumulate the profit into total. 12345678var maxProfit = function(prices) { let n = prices.length let total = 0 for (i = 0; i &lt; n; i++) { if (prices[i + 1] &gt; prices[i]) total += prices[i + 1] - prices[i] } return total} Question Source - Leetcode","link":"/2019/10/07/best-time-to-buy-and-sell-stock-ii/"},{"title":"TIL-191007","text":"Today I Learned First exposure to React 2 libraries needed - React &amp; ReactDOM Babel turns JSX into HTML JSX vs HTML Syntax: camelCase vs lower case; className vs class Styling: JSX uses { } Referencing JS variablesNote: Refer to browser console for more differences import [ES2015] vs require [CommonJS] Leetcode - Convert Sorted Array to BST Solving tree problem using recursive method","link":"/2019/10/08/TIL-191007/"},{"title":"TIL-191008","text":"Today I Learned React Component Nesting Component Hierarchy Component Reusability Component Configuration - Props (parent to child) Component Types Functional Components : Good for simple content Class Components: Good for just about everything else Easier code organization Can use ‚Äòstate‚Äô (another React system) Understands lifecycle events","link":"/2019/10/09/TIL-191008/"},{"title":"TIL-191009","text":"Today I Learned Data Structure : Tree Traversing tree structure in Depth-First Search (DFS) &amp; Breadth-First Search (BFS) method. DFS consists of 3 traversal method Pre-order traversal : Root ‚Üí Left ‚Üí Right Post-order traversal : Left ‚Üí Right ‚Üí Root Inorder traversal : Left ‚Üí Root ‚Üí Right DFS makes use of stack for iterative approach while BFS uses queue. Stack is LIFO vs Queue is FIFO. More about Tree","link":"/2019/10/10/TIL-191009/"},{"title":"Binary Tree Traversal","text":"Binary Tree Traversal Depth-First SearchPre-order Traversal Pre-order traversal is to visit the root first.Then traverse the left subtree.Finally, traverse the right subtree. [ A ‚Üí B ‚Üí D ‚Üí E ‚Üí C ‚Üí F ‚Üí G ] Javascript Solution 12345678910111213141516171819var preorderTraversal = function(root) { //corner case if (root == null) return [] //declarations let result = [] let stack = [root] while (stack.length) { //initially, stack.length is 1 let pointer = stack.pop() //node pointer result.push(pointer.val) //insert pointed node at the end of result if (pointer.right) { stack.push(pointer.right) //stack right subtree first } if (pointer.left) { stack.push(pointer.left) //stack left subtree on top of right subtree } //iterate until stack is empty } return result} In-order Traversal In-order traversal is to traverse the left subtree first.Then visit the root.Finally, traverse the right subtree. [D ‚Üí B ‚Üí E ‚Üí A ‚Üí F ‚Üí C ‚Üí G] Javascript Solution 123456789101112131415161718192021var inorderTraversal = function(root) { //corner case if (root == null) return [] //declaration let result = [] let stack = [] let pointer = root while (stack.length || pointer) { if (pointer) { //if pointed node is not null stack.push(pointer) //store pointed node at the top of stack pointer = pointer.left //shift pointer to left node } else { //if pointed node is null (reached the leaf) pointer = stack.pop() //assign extracted top stack value to pointer result.push(pointer.val) //insert pointed node at the end of result pointer = pointer.right //shift pointer to right node } } return result} Post-order Traversal Post-order traversal is to traverse the left subtree first.Then traverse the right subtree.Finally, visit the root. [D ‚Üí E ‚Üí B ‚Üí F ‚Üí G ‚Üí C ‚Üí A] Javascript Solution 123456789101112131415161718var postorderTraversal = function(root) { //corner case if (root == null) return [] //declarations let result = [] let stack = [root] while (stack.length) { let pointer = stack.pop() //node pointer result.unshift(pointer.val) //insert pointed node at the front of result if (pointer.left) { stack.push(pointer.left) //stack left subtree first } if (pointer.right) { stack.push(pointer.right) //stack right subtree on top of left subtree } } return result} Breadth-First SearchLevel-order traversal is to traverse the tree level by level. Breadth-First Search is an algorithm to traverse or search in data structures like a tree or a graph. The algorithm starts with a root node and visit the node itself first. Then traverse its neighbors, traverse its second level neighbors, traverse its third level neighbors, so on and so forth. ie. Given Binary Tree 12345 3 / \\9 20 / \\ 15 7 returns 12345[ [3], [9,20], [15,7]] Javascript Solution 12345678910111213141516171819202122var levelOrder = function(root) { if (root == null) return [] let result = [] let queue = [root] while (queue.length) { let size = queue.length let temp = [] for (i = 0; i &lt; size; i++) { // iterate through # of child nodes let node = queue.shift() // queue uses shift vs stack uses pop (see Note) temp.push(node.val) if (node.left) { queue.push(node.left) // queue left subtree first } if (node.right) { queue.push(node.right) // queue right subtree after left subtree } } result.push(temp) } return result} After queue (before) temp queue (after) result 1st Iteration [3 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ 3 ] [9 ‚Üí ‚Ä¢‚Ä¢‚Ä¢, 20 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ [3] ] 2nd Iteration (inner loop) [9 ‚Üí ‚Ä¢‚Ä¢‚Ä¢, 20 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ 9 ] [20 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ [3], [9] ] 2nd Iteration (inner loop) [20 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ 9, 20 ] [15 ‚Üí ‚Ä¢‚Ä¢‚Ä¢, 7 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ [3], [9,20] ] 3rd Iteration (inner loop) [15 ‚Üí ‚Ä¢‚Ä¢‚Ä¢, 7 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ 15 ] [7 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ [3], [9,20], [15] ] 3rd Iteration (inner loop) [7 ‚Üí ‚Ä¢‚Ä¢‚Ä¢] [ 7 ] [ ] [ [3], [9,20], [15,7] ] Note: Stack: LIFO (Last In First Out) ie. Stack of Plates Queue: FIFO (First In First Out) ie. Queue in the movie References: Question Source - Leetcode Data Structures: Stacks &amp; Queues Data Structure &amp; Algorightms - Tree Traversal","link":"/2019/10/10/binary-tree-series/"},{"title":"Excel Sheet Column Number","text":"ProblemGiven a column title as appear in an Excel sheet, return its corresponding column number. For example: 12345678A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28... Example 1: 12Input: &quot;A&quot;Output: 1 Example 2: 12Input: &quot;AB&quot;Output: 28 Attempt Convert alphabet to integer Solution 123456789var titleToNumber = function(s) { let sum = 0 let n = s.length for (i = 0; i &lt; n; i++) { let num = s.charCodeAt(i) - 64 sum += Math.pow(26, n - 1 - i) * num } return sum} Question Source - Leetcode","link":"/2019/10/11/excel-sheet-column-number/"},{"title":"TIL-191011","text":"Today I Learned DS &amp; Algo Excel Sheet Column Number str.charCodeAt(i) converts alphabet to integer at specific sequence. Math.pow(n,m) =&gt; $n^m$ Grading Student Math.ceil(x/5)*5 rounds up number to the nearest 5 Math.floor rounds down number","link":"/2019/10/12/TIL-191011/"},{"title":"TIL-191010","text":"Today I Learned React Concept State is initialized at constructor setState updates the State and re-renders Project - Calculator Pilot","link":"/2019/10/11/TIL-191010/"},{"title":"Grading Students","text":"ProblemHackerLand University has the following grading policy: Every student receives a grade in the inclusive range from 0 to 100.Any grade less than 40 is a failing grade. Sam is a professor at the university and likes to round each student‚Äôs according to these rules: If the difference between the grade and the next multiple of 5 is less than 3, round grade up to the next multiple of 5. If the value of grade is less than 38, no rounding occurs as the result will still be a failing grade. For example:Sample Input 12345473673833 Sample Output 123475674033 Attempt Convert alphabet to integer Solution 123456789101112131415let ans = []for (let i = 0; i &lt; grades.length; i++) { if (grades[i] &lt; 38) { //failing grade ans.push(grades[i]) } else if (grades[i] % 5 &lt; 3) { //do not round up ans.push(grades[i]) } else if (grades[i] % 5 &gt;= 3) { //round up let roundUp = Math.ceil(grades[i] / 5) * 5 ans.push(roundUp) }}return ans Question Source - Hacker Rank","link":"/2019/10/15/grading-students/"},{"title":"TIL-191014","text":"Today I Learned React Conventional File Structure 12345- index- components - App.js - ThisComponent.js - ThatComponent.js Event Handler (JSX) OnChange OnClick OnSubmitNote: naming convention - On_Form/Input_Change(Click/Submit) Uncontrolled vs Controlled Element Controlled Element is preferred as it stores data inside React Components instead of HTML this calls from ____.____ Axios vs Fetch Axios is 3rd party library while fetch is in-built Fetch is light while Axios is more complex Axios has more functionality and thus, preferred.","link":"/2019/10/15/TIL-191014/"},{"title":"First Unique Character In a String","text":"ProblemGiven a string, find the first non-repeating character in it and return it‚Äôs index. If it doesn‚Äôt exist, return -1. Example: 12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. Attempt1st Attempt Create map that stores alphabets as key and its frequency as values. Convert alphabet to integer 123456789101112131415161718var firstUniqChar = function(s) { let map = {} for (i = 0; i &lt; s.length; i++) { //initialise map //if specific letter exist, 1. Otherwise, increase by 1 map[s[i]] ? map[s[i]]++ : (map[s[i]] = 1) } let keys = Object.keys(map) //convert obj key to array let vals = Object.values(map) //convert obj value to array let index = vals.indexOf(1) //find position with alphabet count 1 in val arr let letter = \"\" if (index == -1) return -1 //corner case else { letter = keys[index] //find position in key arr } return s.indexOf(letter)} Runtime: 100 ms, faster than 49.16% of JavaScript online submissions for First Unique Character in a String. Memory Usage: 38.4 MB, less than 60.00% of JavaScript online submissions for First Unique Character in a String. 2nd Attempt (More Effieicient) 12345678910var firstUniqChar = function(s) { let freq = new Array(26).fill(0) for (i = 0; i &lt; s.length; i++) { freq[s.charCodeAt(i) - 97]++ } for (i = 0; i &lt; s.length; i++) { if (freq[s.charCodeAt(i) - 97] == 1) return i } return -1} Runtime: 60 ms, faster than 99.53% of JavaScript online submissions for First Unique Character in a String. Memory Usage: 37.8 MB, less than 82.50% of JavaScript online submissions for First Unique Character in a String. Source - Leetcode","link":"/2019/10/16/first-unique-character-in-a-string/"},{"title":"TIL-191015","text":"Today I Learned DS &amp; Algo Hash Table provides high performance for insertion and searching of element. Only inbuilt function in C++, Java, Python. Hash Table consist of Hash Map and Hash Set. Hash Set contains no identical value and Hash Map has key value pair that counts the frequency of the key as value. In Javascript, Set in ES6 provides similar functionality to hash set. React After rendering HTML elements in DOM, if need to access the data from HTML elements, use React Refs. How to use? Create in constructor fxn &amp; pass to JSX as props","link":"/2019/10/16/TIL-191015/"},{"title":"TIL-191016","text":"Today I Learned JavaScript New Syntax object delete: can delete a key value pair extends: class x (child) extends y (parent) React &amp; Node Sending API request from port 4000 (Client) to port 3000 (Server) Since they are running on different ports, they are different JavaScript origin. It doesn‚Äôt matter that they are on the same machine/hostname. CORS (Cross Origin Resource Sharing) Same-Origin Policy : a critical security mechanism that restricts how a document or script loaded from one origin can interact with a resource from another origin CORS introduces a standard mechanism that can be used by all browsers for implementing cross-domain requests.The spec defines a set of headers that allow the browser and server to communicate about which requests are (and are not) allowed.12345678app.use(function(req, res, next) { res.header(\"Access-Control-Allow-Origin\", \"YOUR-DOMAIN.TLD\"); // update to match the domain you will make the request from res.header( \"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\" ); next();});","link":"/2019/10/17/TIL-191016/"},{"title":"TIL-191017","text":"Today I Learned React Pass function to onClick props instead of calling it. Otherwise, It will be called upon rendering without click. (Stack Overflow question) Notice how with onClick={() =&gt; alert('click')}, we‚Äôre passing a function as the onClick prop. React will only call this function after a click.Forgetting () =&gt; and writing onClick={alert('click')} is a common mistake, and would fire the alert every time the component re-renders","link":"/2019/10/21/TIL-191017/"},{"title":"350. Intersection of Two Arrays II","text":"ProblemGiven two arrays, write a function to compute their intersection. Example 1: 12Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2] Example 2: 12Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9] Note: Each element in the result should appear as many times as it shows in both arrays.The result can be in any order. Follow up: What if the given array is already sorted? How would you optimize your algorithm? What if nums1's size is small compared to nums2's size? Which algorithm is better? What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once? Question Source - leetcode SolutionUsing Object1234567891011121314var intersect = function(nums1, nums2) { let map = {} let res = [] for (i = 0; i &lt; nums1.length; i++) { map[nums1[i]] ? map[nums1[i]]++ : (map[nums1[i]] = 1) } for (i = 0; i &lt; nums2.length; i++) { if (map.hasOwnProperty(nums2[i]) &amp;&amp; map[nums2[i]] &gt; 0) { res.push(nums2[i]) map[nums2[i]]-- } } return res} Time Complexity: O(n) Space Complexity: O(n) Using Map (ES6)12345678910111213141516var intersect = function(nums1, nums2) { let map = new Map() let res = [] for (i = 0; i &lt; nums1.length; i++) { let n = nums1[i] map.has(n) ? map.set(n, map.get(n) + 1) : map.set(n, 1) } for (i = 0; i &lt; nums2.length; i++) { let n = nums2[i] if (map.has(n) &amp;&amp; map.get(n) &gt; 0) { res.push(n) map.set(n, map.get(n) - 1) } } return res} Time Complexity: O(n) Space Complexity: O(n)","link":"/2019/10/22/intersection-of-two-arrays-ii/"},{"title":"TIL-191018","text":"Today I Learned DS &amp; Algo Backtracking Recursion problemSo basically in backtracking we attempt solving a subproblem, and if we don‚Äôt reach the desired solution, then undo whatever we did for solving that subproblem, and try solving another subproblem.","link":"/2019/10/21/TIL-191018/"},{"title":"TIL-191021","text":"Today I LearnedSummary DS &amp; Algo : Missing Number React : Redux - Insurance company analogy DS &amp; Algo Completed Missing Number which seemed like Array question but the question hinted that it could be done in linear runtime and constant space complexity - bit manipulation. Array solution involved array sort which slows down the efficiency and matching the number to the supposed number. Next best solution is summing up all integers in solution array and subtracting by integers in given array. Remainder is the integer missing - gaussian xxx Bit manipulation makes use of XOR which gives true output only if the input is odd. e.g. 1 ^ 0 = 1 , 0 ^ 1 = 1 But still confused about if the input is not binary, what would output be? solution suggests nums.length ^ nums[i] ^ i React Redux using analogy of insurance company. Redux consist of Action Creator Action dispatch Reducers State In the analogy, Person drops of a form (Action) stating policy or claim and front desk of insurance company, form receiver (dispatch) hand over the form to insurance departments consisting of accounting, policies and claim history (Reducers). Finally all processed policy or claim comes in form of compiled department data (State)","link":"/2019/10/23/TIL-191021/"},{"title":"Permutations","text":"ProblemGiven a collection of distinct integers, return all possible permutations. Example: 123456789Input: [1, 2, 3];Output: [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]; Question Source - Leetcode Attempt https://leetcode.com/problems/permutations/discuss/293217/Javascript-Backtracking-with-Explanation-beats-99 1234567891011121314151617181920212223242526/** * @param {number[]} nums * @return {number[][]} */const permute = function(nums) { const result = []; const temp = []; findPermutations(temp, nums, result); return result;};const findPermutations = (temp, nums, result) =&gt; { if (!nums.length) { result.push(temp.concat()); return; } for (var i = 0; i &lt; nums.length; i++) { const newNum = nums[i]; temp.push(newNum); nums.splice(i, 1); findPermutations(temp, nums, result); temp.pop(); nums.splice(i, 0, newNum); }};","link":"/2019/10/23/permutations/"},{"title":"TIL-191022","text":"Today I LearnedSummary Javascript : Map vs Object DS &amp; Algo : Array &amp; String React : Redux : redux-thunk JavaScript Map vs Object: Key field: in Object, it follows the rule of normal dictionary. The keys MUST be simple types ‚Äî either integer or string or symbols. Nothing more. But in Map it can be any data type (an object, an array, etc‚Ä¶). Element order: in Map, original order of elements (pairs) is preserved, while in Object, it isn‚Äôt. Inheritance: Map is an instance of Object (surprise surprise!), but Object is definitely not an instance of Map. How to construct Object: direct literal | constructor | Object.prototype.create Map: only 1 way - built-in constructor new Map() DS &amp; Algo Reverse String Attempted in both Leetcode &amp; fCC. In fCC, confusion came as for loop required declaration of i (let i). In Leetcode, solved without using extra space by manipulating the sequence through temp. temp serve as buffer that element getting replaced is stored temporarily before getting placed at the back. It is required to avoid the mutation within the array in for loop. Intersection of two arrays II Used ‚ÄòMap‚Äô to solve the problem. Question differed from version I in a sense that elements in result array were to include repeated ones. eg. Given [2,2] and [1,2,2,1], answer was [2,2]. At first attempted with mapified object, by creating key-value pair with key as number and value as frequency. And then, use another for loop to run through the other array - if object has number key and freq &gt; 0, insert into array and decrease frequency. Realised in javascript, there is Map data type which is subset of Object. It is easier in terms of syntax to find (boolean) and get (value) of the key-value pair as compared to Object. React Use of redux-thunk. Redux-thunk is required to process async function calls in the redux app. Since action can only store plain javascript object as payload, asynchronous function that gets callback later can not be included in the payload. Redux-thunk allows ?? Reference","link":"/2019/10/25/TIL-191022/"},{"title":"TIL-191023","text":"Today I LearnedSummary Javascript : Array iterator type DS &amp; Algo : Array React : Redux - Reducer JavaScript .map() returns a new Array of objects created by taking some action on the original item. .every() returns a boolean - true if every element in this array satisfies the provided testing function. An important difference with .every() is that the test function may not always be called for every element in the array. Once the testing function returns false for any element, no more array elements are iterated. Therefore, the testing function should usually have no side effects. .forEach() returns nothing - It iterates the Array performing a given action for each item in the Array. (https://stackoverflow.com/questions/7340893/what-is-the-difference-between-map-every-and-foreach) DS &amp; Algo Pascal Triangle - Question involving 2 for-loops but I tried to solve through recursive approach first. Took more than necessary without getting it right. Correct approach should be to try brute force method and then try to optimise code. React Redux - Rule of Reducer Must return any value except undefined (1st time called) 2nd time onwards, it takes in previous state and action as argument Reducers are pure (no API calls etc) Must not mutate input state To manipulate input state, new array or object have to be create. eg. [...arr, newElem] instead of arr.push(newElem) Composing Reducer - use switch instead of ifelse Project Use cross-env library to execute bash commands like NODE_ENV=XXXX in Windows env","link":"/2019/10/25/TIL-191023/"},{"title":"TIL-191024","text":"Today I LearnedSummary DS &amp; Algo : Array React : Redux API call optimization DS &amp; Algo Attempted Happy Number (Easy) and solved without help in 40 mins. React ownProps as 2nd arg in mapStateToProps memoization when using redux-thunk to reduce overfetching","link":"/2019/10/26/TIL-191024/"},{"title":"TIL-191028","text":"Today I LearnedSummary DS &amp; Algo : Array / Big O Notation React : Redux-thunk DS &amp; Algo Array (2 pointers) - remove duplicate elements in sorted array Big O Notation : number of operations the computer has to do in terms of runtime &amp; space React React-thunk - needed for async call in the action React Lifecycle: render ‚Üí componentDidMount : any other way than using ‚ÄòLoading‚Äô ? https://programmingwithmosh.com/javascript/react-lifecycle-methods/","link":"/2019/10/28/TIL-191028/"},{"title":"TIL-191029","text":"Today I LearnedSummary Data Structure &amp; Algorithm - Bit Manipulation React - Redux-Saga DS &amp; Algo Number of Bits | Leetcode Bit manipulation - n &amp; n-1 ‚áí n and 0 &amp; 1 = 0to remove 1s React redux-saga vs redux-thunk Similarity: Both allow asynchronous calls to be processed in redux. Difference: - thunk: Utilise callback functions - saga: can be started, paused &amp; cancelled from main application using ES6 Generator function &amp; much easier for testingReference","link":"/2019/10/29/TIL-191029/"},{"title":"Number of 1 Bits","text":"ProblemWrite a function that takes an unsigned integer and return the number of ‚Äò1‚Äô bits it has (also known as the Hamming weight). Example 1: 123Input: 00000000000000000000000000001011Output: 3Explanation: The input binary string 00000000000000000000000000001011 has a total of three &apos;1&apos; bits. Example 2: 123Input: 00000000000000000000000010000000Output: 1Explanation: The input binary string 00000000000000000000000010000000 has a total of one &apos;1&apos; bit. Example 3: 123Input: 11111111111111111111111111111101Output: 31Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &apos;1&apos; bits. Question Source: LeetCode AttemptBrute Force Change n to binary using Number.toString(2) Store in String using template literal Iterate &amp; count 1 123456789101112/** * @param {number} n - a positive integer * @return {number} */var hammingWeight = function(n) { let str = `${n.toString(2)}` let count = 0 for (let i = 0; i &lt; str.length; i++) { if (str[i] == \"1\") count++ } return count} Bit Manipulation Rule of Thumb: Even number always ends with 0 &amp; odd number always ends with 1 1 &amp; 0 == 0 -&gt; removes one n &amp; (n-1) drops 1 each time 1234567891011121314/** * @param {number} n - a positive integer * @return {number} */var hammingWeight = function(n) { let count = 0 while (n) { n = n &amp; (n - 1) count++ } return count} ReferenceBits, Bytes, Building With Binary","link":"/2019/10/29/number-of-1-bits/"},{"title":"TIL-191030","text":"Today I LearnedSummary React Project React mapStateToProps vs mapDispatchToProps mapStateToProps: It connects redux state to props of react component. mapDispatchToProps: It connects redux actions to react props. Project Puppeteer Puppeteer is a Node library which provides a high-level API to control headless Chrome or Chromium. It can be used to programmatically perform actions on chrome (ie. Scraping) elementHandle.click() vs page.evaluate(() =&gt; { document.getElementById('xx').click() })","link":"/2019/10/31/TIL-191030/"},{"title":"Missing Number","text":"ProblemGiven an array containing n distinct numbers taken from 0, 1, 2, ‚Ä¶, n, find the one that is missing from the array. Example 1: 12Input: [3,0,1]Output: 2 Example 2: 12Input: [9,6,4,2,3,5,7,0,1]Output: 8 Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Question Source - Leetcode Solution1st Attempt12345678var missingNumber = function(nums) { nums.sort((a, b) =&gt; a - b) for (i = 0; i &lt;= nums.length; i++) { if (i !== nums[i]) { return i } }} Time Complexity: O(nlgn) due to sort Space Complexity: O(1) Improved Using Gauss‚Äô Formula 12345678var missingNumber = function(nums) { let n = nums.length let sum = ((0 + n) * (n + 1)) / 2 for (i = 0; i &lt; n; i++) { sum -= nums[i] } return sum} Time Complexity: O(n) Space Complexity: O(1) BitwiseUsing XOR concept: XOR is its own inverse 1234missing =4^(0^0)^(1^1)^(2^3)^(3^4) =(4^4)^(0^0)^(1^1)^(3^3)^2 =0^0^0^0^2 =2 ‚Äã 1234567var missingNumber = function(nums) { let res = nums.length for (i = 0; i &lt; nums.length; i++) { res ^= i ^ nums[i] } return res} Time Complexity: O(n) Space Complexity: O(1)","link":"/2019/10/31/missing-number/"},{"title":"Reverse String","text":"ProblemWrite a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. Example 1: 12Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] Example 2: 12Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] Question Source: LeetCode Solution1234567891011121314151617/** * @param {character[]} s * @return {void} Do not return anything, modify s in-place instead. */var reverseString = function(s) { let n = s.length let temp = 0 // Iterate for half the number of string for (let i = 0; i &lt; n / 2; i++) { // Store 1st half chars in dummy temp = s[i] // Swap 2nd half char with 1st half s[i] = s[n - 1 - i] // Release stored value to 2nd half chars s[n - 1 - i] = temp }} Runtime: O(n) Space: O(1)","link":"/2019/10/31/reverse-string/"},{"title":"Remove Duplicate from Sorted Array","text":"ProblemGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: 1234567Input:[1,1,2],Output:- length = 2- [1,2]It doesn&apos;t matter what you leave beyond the returned length. Example 2: 12345678Input:[0,0,1,1,1,2,2,3,3,4],Output:- length = 5- [0,1,2,3,4]It doesn&apos;t matter what values are set beyond the returned length. Solution1st Attempt1234567891011121314/** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { let i = 0 while (i &lt; nums.length) { // if consecutive elem has same number, remove cur elem if (nums[i] == nums[i + 1]) nums.splice(i, 1) else { i++ } }} Runtime:O(n¬≤) Space: O(1) (in-place) Improved Two Pointers: i slow-runner &amp; j fast-runner 12345678910111213/** * @param {number[]} nums * @return {number} */var removeDuplicates = function(nums) { let i = 0 for (let j = 0; j &lt; nums.length; j++) { //if consecutive elem not equal, copy j value to i+1 position if (nums[j] != nums[i]) nums[++i] = nums[j] } //return length return i + 1} Runtime:O(n) Space: O(1) (in-place)","link":"/2019/10/31/remove-duplicate-from-sorted-array/"},{"title":"100. Same Tree","text":"ProblemGiven two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 1234567Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false Solution Iterative Approach 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} p * @param {TreeNode} q * @return {boolean} */var isSameTree = function(p, q) { let stack1 = [p] let stack2 = [q] // Base Case if (p == null &amp;&amp; q == null) return true if (p == null &amp;&amp; q !== null) return false if (p !== null &amp;&amp; q == null) return false //Tree Traversal for p &amp; q simultaneously while (stack1.length) { //Unload Stack let tn1 = stack1.pop() let tn2 = stack2.pop() //Check if node have same value if (tn1.val !== tn2.val) return false //Check if node have same structure - null hell if (tn1.left == null &amp;&amp; tn2.left != null) { //left return false } else if (tn1.left != null &amp;&amp; tn2.left == null) { //left return false } else if (tn1.right == null &amp;&amp; tn2.right != null) { //right return false } else if (tn1.right != null &amp;&amp; tn2.right == null) { //right return false } //Assuming all same, traverse tree using stack if (tn1.right) stack1.push(tn1.right) if (tn2.right) stack2.push(tn2.right) if (tn1.left) stack1.push(tn1.left) if (tn2.left) stack2.push(tn2.left) } return true} Time Complexity: O(n) space Complexity: O(n)","link":"/2019/11/04/same-tree/"},{"title":"11. Container with Most Water","text":"ProblemGiven n non-negative integers a1, a2, ‚Ä¶, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 Question Source - Leetcode SolutionBrute Force Set Two Pointers i, j (j should be i+1) Calculate local Area (height, minimum of height i vs j * distance, j-i) Deduce greater Area between current Area vs previous Area and save as maxArea 1234567var maxArea = function(height) { let maxarea = 0 for (i = 0; i &lt; height.length; i++) for (j = i + 1; j &lt; height.length; j++) maxarea = Math.max(maxarea, Math.min(height[i], height[j]) * (j - i)) return maxarea} Time Complexity: O(n^2^) Space Complexity: O(1) Two PointersSince Area = height * distance, since moving the pointers means decreasing the distance (j-i), for Area to be higher than before, height must be higher. Thus, we move between height[i] vs height[j], whichever is lower in value. 12345678910var maxArea = function(height) { let maxarea = 0 let i = 0, j = height.length - 1 while (i &lt; j) { maxarea = Math.max(maxarea, Math.min(height[i], height[j]) * (j - i)) height[i] &lt; height[j] ? i++ : j-- } return maxarea} Time Complexity: O(n) Space Complexity: O(1)","link":"/2019/11/04/container-with-most-water/"},{"title":"TIL-191107","text":"Today I LearnedSummary Data Structure &amp; Algorithm - Sliding Window Technique React - Functional vs Class components Data Structures &amp; AlgorithmsSliding Window This pattern involves creating a window which can either be an array or number from one position to another Depending on a certain condition, the window either increases or closes (and a new window is created) Very useful for keeping track of a subset of data in an array/string etc. Example Write a function called maxSubarraySum which accepts an array of integers and a number called n. The function should calculate the maximum sum of n consecutive elements in the array. 12maxSubarraySum([1,2,5,2,8,1,5],2) // 10maxSubarraySum([1,2,5,2,8,1,5],4) // 17 12345678910111213141516function maxSubarraySum(arr, num) { let maxSum = 0; let tempSum = 0; if (arr.length &lt; num) return null; for (let i = 0; i &lt; num; i++) { maxSum += arr[i]; } tempSum = maxSum; for (let i = num; i &lt; arr.length; i++) { //move along array tempSum = tempSum - arr[i - num] + arr[i]; //save max value maxSum = Math.max(maxSum, tempSum); } return maxSum;} React Functional vs Class Components in React Functional component easier to read &amp; test (less code) Use functional component for presentational component","link":"/2019/11/07/TIL-191107/"},{"title":"202. Happy Number","text":"ProblemWrite an algorithm to determine if a number is ‚Äúhappy‚Äù. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 1234567Input: 19Output: trueExplanation:12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1 Question Source: LeetCode Solution Solved in 40 mins without reference Used array as storage to refer to previously stored value but could use hash map concept. 123456789101112131415161718192021/** * @param {number} n * @return {boolean} */var isHappy = function(n) { if (n == 1) return true let res = n let stack = [] while (res !== 1 &amp;&amp; !stack.includes(res)) { stack.push(res) let num = `${res}` let nums = num.split(\"\") let sum = 0 nums.forEach(el =&gt; { sum += Math.pow(el, 2) }) res = sum if (res === 1) return true } return false}","link":"/2019/11/05/happy-number/"},{"title":"217. Contains Duplicate","text":"ProblemGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. Example 1: 12Input: [1,2,3,1]Output: true Example 2: 12Input: [1,2,3,4]Output: false Example 3: 12Input: [1,1,1,3,3,4,3,2,4,2]Output: true SolutionSort &amp; Compare1234567891011/** * @param {number[]} nums * @return {boolean} */var containsDuplicate = function(nums) { var sorted = nums.sort(); for (i = 1; i &lt; sorted.length; i++) { if (sorted[i] == sorted[i - 1]) return true; } return false;}; Time Complexity: O(N lgN) Space Complexity: O(1) Using Hashmap12345678910111213/** * @param {number[]} nums * @return {boolean} */var containsDuplicate = function(nums) { let hashmap = {}; for (i = 0; i &lt; nums.length; i++) { let num = nums[i]; hashmap[num] ? hashmap[num]++ : (hashmap[num] = 1); if (hashmap[num] !== 1) return true; } return false;}; Time Complexity: O(N) Space Complexity: O(N) Using Hash Map12345678910111213/** * @param {number[]} nums * @return {boolean} */var containsDuplicate = function(nums) { let hashmap = {}; for (i = 0; i &lt; nums.length; i++) { let num = nums[i]; hashmap[num] ? hashmap[num]++ : (hashmap[num] = 1); if (hashmap[num] !== 1) return true; } return false;};","link":"/2019/11/12/contains-duplicate/"},{"title":"3. Longest Substring Without Repeating Characters","text":"ProblemGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 123Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, ‚Äúpwke‚Äù is a subsequence and not a substring. Question Source - leetcode SolutionSliding Window Technique 12345678910111213141516171819/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function(s) { let maxSubstr = \"\"; let max = 0; /* Extract first max non-repeating substr */ for (i = 0; i &lt; s.length; i++) { let index = maxSubstr.indexOf(s[i]); //construct maximum substring maxSubstr += s[i]; //cut out constructed max subarray if (index &gt;= 0) maxSubstr = maxSubstr.substring(index + 1); //save maximum length max = Math.max(max, maxSubstr.length); } return max;}; Time Complexity: O(N) Space Complexity: O(1) Review X -&gt; Cutting out at position after max subarray instead of after the repeated array (eg. abcabc - abc,abc vs abc, bca, cab)","link":"/2019/11/07/longest-substring-without-repeating-characters/"},{"title":"TIL-191112","text":"Today I LearnedSummary Javascript: Memory Model JavascriptJavaScript‚Äôs Memory Model Variable declarations and assignments for JS primitives What actually happens in memory when we declare &amp; assign value? 123let myNumber = 23;let newVar = myNumber;myNumber = myNumber + 1; The call stack is where primitives are stored (in addition to function calls). While the heap is where non-primitives are stored. The key difference is that the heap can store unordered data that can grow dynamically‚Äîperfect for arrays and objects. Variable declarations and assignments for JS non-primitives What actually happens in memory when we declare &amp; assign value? 1let myArray = []; Let vs Const The correct way to interpret ‚Äúchange‚Äù is a change in memory address. Let allows you to change memory addresses. Const does not allow you to change memory addresses. 12345678let sum = 0;sum = 1 + 2 + 3 + 4 + 5;let numbers = []; // WRONG! Use constnumbers.push(1);numbers.push(2);numbers.push(3);numbers.push(4);numbers.push(5); Google, who has some of the best coders in the world, says in their JavaScript style guide, ‚ÄúDeclare all local variables with either const or let. Use const by default, unless a variable needs to be reassigned. The var keyword must not be used‚Äù Source: https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239","link":"/2019/11/13/TIL-191112/"},{"title":"22. Generate Parentheses","text":"ProblemGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: 1[&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;]; Question Source - Leetcode Solution12345678910111213141516171819202122232425/** * @param {number} n * @return {string[]} */var generateParenthesis = function(n) { let res = []; let par = \"\"; backtrack(res, par, 0, 0, n); return res;};const backtrack = (res, par, open, close, max) =&gt; { if (par.length == max * 2) { //base case - str has 6 parentheses res.push(par); return; } if (open &lt; max) // add open parenthesis backtrack(res, par + \"(\", open + 1, close, max); //recursive call after increasing open by 1 if (close &lt; open) // add corresponding close parenthesis backtrack(res, par + \")\", open, close + 1, max);};","link":"/2019/11/13/generate-parentheses/"},{"title":"TIL-191113","text":"Today I LearnedSummary Javascript: Callbacks, Promises &amp; Async Await There are different ways to execute asynchronous function Callbacks123456789101112131415function printString(string, callback) { setTimeout(() =&gt; { console.log(string) callback() }, Math.floor(Math.random() * 100) + 1)}function printAll() { printString(\"A\", () =&gt; { printString(\"B\", () =&gt; { printString(\"C\", () =&gt; {}) }) })}printAll() Callback Hell Nesting functions within functions within functions Hard to read the code. Promises123456789101112131415function printString(string) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(string) resolve() }, Math.floor(Math.random() * 100) + 1) })}function printAll() { printString(\"A\") .then(() =&gt; printString(\"B\")) .then(() =&gt; printString(\"C\"))}printAll() The code is no longer nested but it still looks messy! Await123456async function printAll() { await printString(\"A\") await printString(\"B\") await printString(\"C\")}printAll() Await is basically syntactic sugar for Promises. It makes your asynchronous code look more like synchronous/procedural code, which is easier for humans to understand. Reference: https://medium.com/front-end-weekly/callbacks-promises-and-async-await-ad4756e01d90","link":"/2019/11/14/TIL-191113/"},{"title":"209. Minimum Size Subarray Sum","text":"ProblemGiven an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ‚â• s. If there isn‚Äôt one, return 0 instead. Example: 123Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up:If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). Question Source - Leetcode SolutionUsing Sliding Window Technique123456789101112131415161718192021222324252627/** * @param {number} s * @param {number[]} nums * @return {number} */var minSubArrayLen = function(s, nums) { let sum = 0, start = 0, end = 0, minLen = Infinity; while (start &lt; nums.length) { // As long as sum is less than s, increase the end of the window if (sum &lt; s &amp;&amp; end &lt; nums.length) { sum += nums[end]; end++; } else if (sum &gt;= s) { // If sum exceeds s, save existing array length and // shorten window by increasing the start of the window minLen = Math.min(minLen, end - start); sum -= nums[start]; start++; } else { break; } } return minLen === Infinity ? 0 : minLen;}; Time Complexity : O(n) Space Complexity: O(1)","link":"/2019/11/16/minimum-size-subarray-sum/"},{"title":"TIL-191117","text":"Today I LearnedSummary CSS: Flex vs Grid CSS - Flex vs Grid Grid is Container-Based, Flexbox is Content-Based Flexbox is One Dimensional, Grid is Two Dimensional Grid Has a ‚ÄúGap‚Äù Property, Flexbox Doesn‚Äôt Flexbox Wraps vs Grid Wraps Flexbox covers more browser support vs Grid Source: https://www.webdesignerdepot.com/2018/09/grid-vs-flexbox-which-should-you-choose/ https://hackernoon.com/the-ultimate-css-battle-grid-vs-flexbox-d40da0449faf","link":"/2019/11/17/TIL-191117/"},{"title":"509. Fibonacci Number","text":"ProblemThe Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), for N &gt; 1.Given N, calculate F(N). Example 1: 123Input: 2Output: 1Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: 123Input: 3Output: 2Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: 123Input: 4Output: 3Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Note: 0 ‚â§ N ‚â§ 30. Question Source - Leetcode SolutionUsing Recursion123456789/** * @param {number} N * @return {number} */var fib = function(N) { if (N == 0) return 0 if (N == 1 || N == 2) return 1 return fib(N - 1) + fib(N - 2)} Time complexity: O(2^n)- since T(n) = T(n-1) + T(n-2)is an exponential time Space complexity: O(n) - space for recursive function call stack","link":"/2019/11/19/fibonacci-number/"},{"title":"TIL-191118","text":"Today I LearnedSummary CSS : Making Menu button CSSHow to make 3 dotted menu button with drop down onclick HTML structure 12345678910111213141516171819&lt;body&gt; &lt;div class=\"header\"&gt; &lt;!-- three dot menu --&gt; &lt;div class=\"dropdown\"&gt; &lt;!-- three dots --&gt; &lt;ul class=\"dropbtn icons btn-right showLeft\" onclick=\"showDropdown()\"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!-- menu --&gt; &lt;div id=\"myDropdown\" class=\"dropdown-content\"&gt; &lt;a href=\"#home\"&gt;Home&lt;/a&gt; &lt;a href=\"#about\"&gt;About&lt;/a&gt; &lt;a href=\"#contact\"&gt;Contact&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; CSS Styling 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687* { margin: 0; padding: 0px;}.showLeft { background-color: #0d77b6 !important; border: 1px solid #0d77b6 !important; text-shadow: none !important; color: #fff !important; padding: 10px;}.icons li { background: none repeat scroll 0 0 #fff; height: 7px; width: 7px; line-height: 0; list-style: none outside none; margin-right: 15px; margin-top: 3px; vertical-align: top; border-radius: 50%; pointer-events: none;}//show on left side of the page.btn-left { left: 0.4em;}//show on right side of the page.btn-right { right: 0.4em;}.btn-left,.btn-right { position: absolute; top: 0.24em;}.dropbtn { background-color: #4caf50; position: fixed; color: white; font-size: 16px; border: none; cursor: pointer;}.dropbtn:hover,.dropbtn:focus { background-color: #3e8e41;}//Dropdown.dropdown { position: absolute; display: inline-block; right: 0.4em;}.dropdown-content { display: none; position: relative; margin-top: 60px; background-color: #f9f9f9; min-width: 160px; overflow: auto; box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2); z-index: 1;}.dropdown-content a { color: black; padding: 12px 16px; text-decoration: none; display: block;}.dropdown a:hover { background-color: #f1f1f1;}.show { display: block;} Javascript 1234567891011121314151617function showDropdown() { document.getElementById(\"myDropdown\").classList.toggle(\"show\")}// Close the dropdown if the user clicks outside of itwindow.onclick = function(event) { if (!event.target.matches(\".dropbtn\")) { var dropdowns = document.getElementsByClassName(\"dropdown-content\") var i for (i = 0; i &lt; dropdowns.length; i++) { var openDropdown = dropdowns[i] if (openDropdown.classList.contains(\"show\")) { openDropdown.classList.remove(\"show\") } } }} Source: https://stackoverflow.com/questions/30260195/how-to-make-3-vertical-dots-using-css/30266001","link":"/2019/11/18/TIL-191118/"},{"title":"TIL-191119","text":"Today I LearnedSummary Data Structure &amp; Algorithm : Recursion Web Scraping: NodeJS + Puppeteer Data Structure &amp; Algorithm : Recursion Recusion: A process that calls itself Real-life use case: json.parse document.getElementById &amp; DOM traversal algorithms Object traversal How it works: Invoke the same function with a different input until reached with base case Required Components: Base Case: The condition when the recursion ends. (most important*) Different Input eg. 1234function sumRange(num) { if (num === 1) return 1 return num + sumRange(num - 1)} Helper method recursion 12345678function outer(input){ let outerScopedVariable = []; function helper(helperInput){ // modify the outerScopedVariable helper(helperInput--); } helper(input); return outerScopedVariable; Big O notation Time Complexity: number of recursive calls to make relative to input Space Complexity: max number of functions on the call stack at a given time Web Scraping (Puppeteer) : XpathXpath is nothing but XML path, the developer used XPath to validate XML files. HTML also follows the same structures as XML, so we can apply XPath to HTML pages as well along with Puppeteer. XPath should be given the last priority among locators because Xpath is slower compared with other locators. Use only if we are not able to find the element with id, name, linktext, css then only we should go for xpath. Xpath SyntaxXpath = tagName[@attribute = attribute's valueHTML code Syntax 1234&lt;tagName attribute1=\"attribute1_value\" attribute2=\"attribute2_value\" &gt;Text&lt;/tagName&gt;eg. &lt;a href=\"https:google.com\" class=\"idle\"&gt;Google&lt;/a&gt; Absolute XpathXpath = /tagName[@attribute = attribute's value/ - point to first node on the html document Relative XpathXpath = //tagName[@attribute = attribute's value// - point to any node in the webpage Use Case : Instagram Scraping 1234//HTML element;&lt;a href='/accounts/login/?source=auth_switcher'&gt;Log In&lt;/a&gt;//Using Puppeteer's inbuilt xpath selector to fetch above elementinstagram.page.$x('//a[contains(text(), \"Log in\")]')","link":"/2019/11/19/TIL-191119/"},{"title":"287. Find the Duplicate Number","text":"ProblemGiven an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 12Input: [1,3,4,2,2]Output: 2 Example 2: 12Input: [3,1,3,4,2]Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. Question Source - Leetcode SolutionAccording to the conditions, sorting or new Set/Object creation is not allowed. Two Pointers123456789101112131415161718192021/** * @param {number[]} nums * @return {number} */var findDuplicate = function(nums) { let i = 0, j = i + 1 while (i &lt; nums.length - 1) { // if two pointers have same number return the number if (nums[i] === nums[j]) return nums[i] // move j along else if (j &lt; nums.length - 1) { j++ } // move i along &amp; reset j position else if (j == nums.length - 1) { i++ j = i + 1 } }} Time Complexity: Min O(N) Max O(N^2) Space Complexity: O(1) Floyd‚Äôs Tortoise and Hare (Cycle Detection) To Be Updated","link":"/2019/11/19/find-the-duplicate-number/"},{"title":"TIL-191120","text":"Today I LearnedSummary Data Structure &amp; Algorithm : Search React: React Redux Saga Structure Data Structure &amp; Algorithm : SearchJavaScript Search Methods indexOf includes find findIndex Types of Search (Array) Linear Search Big O of Linear Search: min O(1) max O(n) Binary Search Big O of Binary Serach: min O(1) max O(log n) Why O(log n)?: 16 elements take 4 steps, 32 elements take 5 steps. Reversal of power React: React Redux Saga Structure Above Flow Diagram helped me understand the react-redux-saga lifecycle. Source: https://medium.com/@ravindermahajan/why-use-redux-saga-f3413a3f7e34","link":"/2019/11/20/TIL-191120/"},{"title":"704. Binary Search","text":"ProblemGiven a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1. Example 1: 123Input: nums = [-1,0,3,5,9,12], target = 9Output: 4Explanation: 9 exists in nums and its index is 4 Example 2: 123Input: nums = [-1,0,3,5,9,12], target = 2Output: -1Explanation: 2 does not exist in nums so return -1 Note: You may assume that all elements in nums are unique.n will be in the range [1, 10000].The value of each element in nums will be in the range [-9999, 9999]. Question Source - Leetcode Solution123456789101112131415161718192021/** * @param {number[]} nums * @param {number} target * @return {number} */var search = function(nums, target) { let start = 0, end = nums.length - 1 while (start &lt;= end) { //Beware using of '&lt;=' sign instead of '&lt;' let mid = Math.floor((start + end) / 2) if (target === nums[mid]) { return mid } else if (target &gt; nums[mid]) { start = mid + 1 } else { end = mid - 1 } } return -1} Time Complexity: O(log N) Space Complexity: O(1)","link":"/2019/11/20/binary-search/"},{"title":"TIL-191121","text":"Today I LearnedSummary Data Structure &amp; Algorithm React Data Structures &amp; Algorithms Intro to sorting algorithm https://www.toptal.com/developers/sorting-algorithms React reselect redux-action request - putting authorization bearer","link":"/2019/11/21/TIL-191121/"},{"title":"TIL-191125","text":"Today I LearnedSummary Backend: Deploying puppeteer on Heroku JavaScript: let vs var Backend : Deploying puppeteer on Heroku https://medium.com/@joshblf/web-scraping-with-express-and-puppeteer-1c1b47bb2a21 Note: Hard to work for Instagram due to their 2 factor authentication JavaScript: let vs var https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var","link":"/2019/11/25/TIL-191125/"},{"title":"TIL-191122","text":"Today I LearnedSummary Data Structure &amp; Algorithm: Bubble Sort JavaScript: Wth is ECMAScript? Data Structure &amp; Algorithm: Bubble SortSteps involved: Compare Swap ES5 vs ES2015 1234567/* ES5 */var temp = arr[j]arr[j] = arr[j + 1]arr[j + 1] = temp/* ES2015 */;[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] Optimization if already been swapped in inner loop, assign noSwap to false JavaScript: Wth is ECMAScript? Initial Editions of ECMAScript are named numerically, increasing by 1: ES1, ES2, ES3, ES4, ES5. New editions (starting with 2015) will be named ES followed by the year of release: ES2015, ES2016, ES2017 ECMAScript is a standard. JavaScript is the most popular implementation of that standard.","link":"/2019/11/22/TIL-191122/"},{"title":"TIL-191126","text":"Today I LearnedSummary Data Structure &amp; Algorithm : Selection Sort CSS : Responsive Web Data Structures &amp; Algorithms Selection Sort less swaps than bubble sort O(n) = N^2 runtime CSSResponsive web page creation bootstrap navbar &amp; collapse menu &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; for responsive navbarNote: Require JQuery &amp; bootstrap js is required","link":"/2019/11/26/TIL-191126/"},{"title":"125. Valid Palindrome","text":"ProblemGiven a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: 12Input: &quot;A man, a plan, a canal: Panama&quot;Output: true Example 2: 12Input: &quot;race a car&quot;Output: false Question Source - Leetcode SolutionRecursion123456789101112131415161718192021222324252627282930313233/** * @param {string} s * @return {boolean} */var isPalindrome = function(s) { if (s.length == 0) return true let str = toAlphaNumeric(s) return palindromeChecker(str)}function toAlphaNumeric(s) { let newStr = \"\" for (let i = 0; i &lt; s.length; i++) { let code = s.charCodeAt(i) if ( (code &gt; 47 &amp;&amp; code &lt; 58) || // numeric (0-9) (code &gt; 64 &amp;&amp; code &lt; 91) || // upper alpha (A-Z) (code &gt; 96 &amp;&amp; code &lt; 123) ) { // lower alpha (a-z) newStr += s[i] } } return newStr.toLowerCase()}function palindromeChecker(str) { if (str.length &lt;= 1) return true if (str.length == 2) return str[0] === str[1] if (str[0] === str[str.length - 1]) return palindromeChecker(str.substring(1, str.length - 1)) return false}","link":"/2019/11/29/valid-palindrome/"},{"title":"TIL-191129","text":"Today I LearnedSummary Data Structure &amp; Algorithm : Merge Sort React: Testing with Jest &amp; Enzyme Data Structure &amp; Algorithm : Merge SortPseudocode Build helper function ‚Äòmerge‚Äô that merges two arrays in sorted order by comparing values in each array mergeSort Pseudocode Break up the array into halves until you have arrays that are empty or have 1 element Merge smaller sorted arrays with other sorted arrays until full length Big O O(log n) decompositions O(n) comparisons per decomposition React : Testing with Jest &amp; Enzyme https://medium.com/codeclan/testing-react-with-jest-and-enzyme-20505fec4675","link":"/2019/11/30/TIL-191129/"},{"title":"TIL-191130","text":"Today I LearnedSummary React : Creating Dropdown React : Creating Dropdown https://codedaily.io/tutorials/63/Create-a-Dropdown-in-React-that-Closes-When-the-Body-is-Clicked What is ref? Refs provide a way to access DOM nodes or React elements created in the render method. React Document","link":"/2019/12/01/TIL-191130/"},{"title":"88. Merge Sorted Array","text":"ProblemGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: 12345Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] Question Source - Leetcode Solution Do a regular merge sort but in reverse comparing the largest numbers first, storing (reversed) into the end of the first array going backwards. This way, the elements you‚Äôre merging are never overwritten (that this works is easy to see if you think about it for a moment).Credit - Stackoverflow 1234567891011121314151617181920212223242526272829303132/** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */var merge = function(nums1, m, nums2, n) { let i = m - 1, j = n - 1, k = m + n - 1 while (i &gt;= 0 &amp;&amp; j &gt;= 0) { if (nums1[i] &lt; nums2[j]) { //elem in num2 is higher nums1[k] = nums2[j] //assign to the k th index j-- //move left to next elem in num2 } else { //elem in num1 is equal or higher nums1[k] = nums1[i] //assign to the k th index nums1[i] = nums2[j] //replace num1 elem with num2 elem i-- //move left to next elem in num1 } k-- //move k index left } while (j &gt;= 0) { //if nums2 have remaining elems nums1[k] = nums2[j] j-- k-- }} Time Complexity: O(n) Space Complexity: O(1)","link":"/2019/12/03/merge-sorted-array/"},{"title":"238. Product of Array Except Self","text":"ProblemGiven an array nums of n integers where n &gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Example: 12Input: [1,2,3,4]Output: [24,12,8,6] Note: Please solve it without division and in O(n). Follow up:Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.) Question Source - Leetcode SolutionBreak down of solution array [1, 2, 3, 4] -&gt; [24, 12, 8, 6] = [2*3*4, 1*3*4, 1*2*4, 1*2*3] = [ , 1 , 1*2 , 1*2*3] (L) *[2*3*4, 3*4, 4, ] (R)12345678910111213141516171819202122232425/** * @param {number[]} nums * @return {number[]} */var productExceptSelf = function(nums) { let n = nums.length let L = new Array(n) let R = new Array(n) let res = new Array(n) for (i = 1; i &lt; n; i++) { L[0] = 1 L[i] = L[i - 1] * nums[i - 1] } for (i = n - 2; i &gt;= 0; i--) { R[n - 1] = 1 R[i] = R[i + 1] * nums[i + 1] } for (i = 0; i &lt; n; i++) { res[i] = L[i] * R[i] } return res} Time Complexity: O(3N) ‚âà O(N)Space Complexity: O(N)","link":"/2019/12/12/product-of-array-except-self/"},{"title":"Memory Model","text":"Using JavaScript, declaring variables, initializing them, and assigning them new values later on is something we do on a daily basis. So what actually happens in memory when we declare &amp; assign value? Variable declarations and assignments for JS primitives123let myNumber = 23;let newVar = myNumber;myNumber = myNumber + 1; The call stack is where primitives are stored (in addition to function calls). While the heap is where non-primitives are stored. The key difference is that the heap can store unordered data that can grow dynamically‚Äîperfect for arrays and objects. Variable declarations and assignments for JS non-primitivesWhat actually happens in memory when we declare &amp; assign value? 1let myArray = []; Let vs Const The correct way to interpret ‚Äúchange‚Äù is a change in memory address. Let allows you to change memory addresses. Const does not allow you to change memory addresses. 12345678let sum = 0;sum = 1 + 2 + 3 + 4 + 5;let numbers = []; // WRONG! Use constnumbers.push(1);numbers.push(2);numbers.push(3);numbers.push(4);numbers.push(5); Google, who has some of the best coders in the world, says in their JavaScript style guide, ‚ÄúDeclare all local variables with either const or let. Use const by default, unless a variable needs to be reassigned. The var keyword must not be used‚Äù Reference: https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239","link":"/2019/12/21/javascript-memory-model/"},{"title":"What is 'ES' in JavaScript?","text":"Once you enter the JavaScript world, you see so many terms like ES6, ES2015 and you get - ‚ÄòWth is ES?‚Äô JavaScript: Wth is ECMAScript? ECMAScript is a standard. JavaScript is the most popular implementation of that standard. Initial Editions of ECMAScript are named numerically, increasing by 1: ES1, ES2, ES3, ES4, ES5. New editions (starting with 2015) will be named ES followed by the year of release: ES2015 (=ES6), ES2016, ES2017","link":"/2019/12/31/javascript-ecmascript/"},{"title":"Automating Instagram Likes","text":"Programme that automates Instagram likes for Instagram account growth. Built with üèóÔ∏è Express.js (Node.js) Puppeteer Features üëÄ Likes top 3 recent posts of hashtags provided Setup üöÄ clone, navigate to the root directory, and npm install Create config.js file with IG_ID &amp; IG_PW values Create tags.js file with IG hashtags in array Run program using npm start","link":"/2019/12/10/automating-instagram-likes/"},{"title":"Callbacks, Promises & Async Await","text":"There are different ways to execute asynchronous function in JavaScript. To call a function that does following task: Print a string A, B, C in order After a random amount of time. Callbacks123456789101112131415function printString(string, callback) { setTimeout(() =&gt; { console.log(string); callback(); }, Math.floor(Math.random() * 100) + 1);}function printAll() { printString(\"A\", () =&gt; { printString(\"B\", () =&gt; { printString(\"C\", () =&gt; {}); }); });}printAll(); Callback Hell Nesting functions within functions within functions Hard to read the code. Promises123456789101112131415function printString(string) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(string); resolve(); }, Math.floor(Math.random() * 100) + 1); });}function printAll() { printString(\"A\") .then(() =&gt; printString(\"B\")) .then(() =&gt; printString(\"C\"));}printAll(); The code is no longer nested but it still looks messy! Await123456789101112131415function printString(string) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(string); resolve(); }, Math.floor(Math.random() * 100) + 1); });}async function printAll() { await printString(\"A\"); await printString(\"B\"); await printString(\"C\");}printAll(); Await is basically syntactic sugar for Promises. It makes your asynchronous code look more like synchronous/procedural code, which is easier for humans to understand. Reference: https://medium.com/front-end-weekly/callbacks-promises-and-async-await-ad4756e01d90 https://medium.com/codebuddies/getting-to-know-asynchronous-javascript-callbacks-promises-and-async-await-17e0673281ee","link":"/2019/12/24/callback-promises-async-await/"},{"title":"Bye bye TIL","text":"Changing the format of Today I LearnedI have been recording what I learnt daily in summarised version for past 2 months. While it‚Äôs good to share my learnings on the Internet, I think there is a better format to show what I have learnt. This is why I‚Äôm pausing posting daily summarised version of TIL to switch to posting posts covering topics I learnt in-depth! Stay tuned ‚úåÔ∏è","link":"/2020/01/12/TIL/"},{"title":"912. Sort an Array","text":"ProblemGiven an array of integers nums, sort the array in ascending order. Example 1: 12Input: nums = [5,2,3,1]Output: [1,2,3,5] Example 2: 12Input: nums = [5,1,1,2,0,0]Output: [0,0,1,1,2,5] Constraints:1 &lt;= nums.length &lt;= 50000-50000 &lt;= nums[i] &lt;= 50000 Question Source - Leetcode SolutionBubble Sort1234567891011121314151617181920/** * @param {number[]} nums * @return {number[]} */var bubbleSort = function(nums) { let noSwaps for (let i = nums.length; i &gt; 0; i--) { noSwaps = true for (let j = 0; j &lt; nums.length; j++) { if (nums[j] &gt; nums[j + 1]) { let temp = nums[j + 1] nums[j + 1] = nums[j] nums[j] = temp noSwaps = false } } if (noSwaps) break } return nums} Runtime: O(N^2) Memory: O(1) Selection Sort1234567891011121314var selectionSort = function(nums) { for (let i = 0; i &lt; nums.length; i++) { let lowest = i for (let j = i + 1; j &lt; nums.length; j++) { //find the lowest index if (nums[j] &lt; nums[lowest]) lowest = j } //swap lowest to the front let temp = nums[i] nums[i] = nums[lowest] nums[lowest] = temp } return nums} Runtime: O(N^2) Memory: O(1) Insertion Sort123456789101112var insertionSort = function(nums) { for (var i = 1; i &lt; nums.length; i++) { var curNum = nums[i] for (var j = i - 1; j =&gt; 0; j--) { if (curNum &lt; nums[j]) { nums[j + 1] = nums[j] } else break } nums[j + 1] = curNum } return nums} Runtime: O(N^2) Memory: O(1) Merge SortPseudocode Merge arrays in sorted order Compare each element in two arrays Push higher value to new result array Continue until 1 array is empty Push all the remaining values of the other array to the new result array Merge Sorted Array Break the array into halves until each arrays have one or no elements remaining Merge those arrays with other sorted arrays until back at full length 12345678910111213141516171819202122232425262728293031var mergeArrays = function(arr1, arr2) { let res = [] let i = 0, j = 0 while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) { if (arr1[i] &lt; arr2[j]) { res.push(arr1[i]) i++ } else { res.push(arr2[j]) j++ } } while (i &lt; arr1.length) { res.push(arr1[i]) i++ } while (j &lt; arr2.length) { res.push(arr2[j]) j++ } return res}var mergeSort = function(arr) { if (arr.length &lt;= 1) return arr let mid = Math.floor(arr.length / 2) let left = mergeSort(arr.slice(0, mid)) let right = mergeSort(arr.slice(mid)) return mergeArrays(left, right)} Quick SortPseudocode Set Pivot Select first (or other) element and set as pivot Iterate over rest of the array If pivot value is higher than element of other index Increase the swap index (to keep track) Swap i th element with swap index th element Swap pivot &amp; swap index element return index Quick Sort (Recursion) Base Case : if left &lt; right, return array Set pivot using pivotHelper function Quicksort left of pivot Quicksort right of pivot 12345678910111213141516171819202122232425262728function pivotHelper(arr, start = 0, end = arr.length-1)= { let pivot = arr[start]; let swapIdx = start; function swap(arr, i, j){ let temp = arr[i] arr[i] = arr[j] arr[j] = temp } for(i=1; i&lt;=end; i++){ if(pivot &gt; arr[i]){ swapIdx++ swap(arr, swapIdx, i) } } swap(arr, start, swapIdx) return swapIdx}function quickSort(arr, left = 0; right = arr.length - 1){ if(left &lt; right){ let pivotIdx = pivotHelper(arr,left,right) quickSort(arr,left, pivotIdx - 1) quickSort(arr,pivotIdx + 1, right) } return arr}","link":"/2019/12/16/sort-an-array/"},{"title":"let vs var","text":"ES6 introduced let as a new way to declare ‚Äúlocal‚Äù variable. But what about var? When should one use let or var? Scoping RulesMain difference is scoping rules. Variables declared by var are scoped to the immediate function body (function scope) while let variables are scoped to the immediate enclosing block denoted by { } (block scope). 1234567891011121314function run() { var foo = \"Foo\"; let bar = \"Bar\"; console.log(foo, bar); { let baz = \"Bazz\"; console.log(baz); } console.log(baz); //ReferenceError}run(); The reason why let keyword was introduced to the language was function scope is confusing and was one of the main sources of bugs in JavaScript. HoistingWhile variables declared with var keyword are ‚Äúhoisted‚Äù to the top of the block which means they are accesible in their enclosing scope ven before they are declared: 1234567function run() { console.log(foo); // undefined var foo = \"Foo\"; console.log(foo); // Foo}run(); let variables are not initialized until their definition is evaluated. Accessing them before the initialisation results in a ReferenceError. Variable said to be in ‚Äútemporal dead zone‚Äù from the start of the block until the initialisation is processed. 1234567function checkHoisting { console.log(foo); // ReferenceError let foo = \"Foo\"; console.log(foo); // foo}checkHoisting(); Creating global object propertyAt the top level, let, unlike var does not create a property on the global object: 12345var foo = \"Foo\"; // globally scopedlet bar = \"Bar\"; // globally scopedconsole.log(window.foo); // Fooconsole.log(window.bar); // undefined RedeclarationIn strict mode, var will let you re-declare the same variable in the same scope while let raises a SyntaxError. 1234567\"use strict\";var foo = \"foo1\";var foo = \"foo2\"; // 'foo' is replaced.let bar = \"bar1\";let bar = \"bar2\"; // SyntaxError: Identifier 'bar' has already been declared Reference: https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var","link":"/2020/01/13/let-vs-var/"},{"title":"Merlabot","text":"Merlabot is a Singapore Travel bot for Korean tourists. It gives recommendations on what to eat in Singapore and answers frequently asked questions about Singapore. Built with üèóÔ∏è Express.js (Node.js) PostgreSQL Dialogflow Features üëÄ Answers Frequently Asked Questions about Singapore Select random restaurant from database base on user‚Äôs preferred cuisine","link":"/2019/12/10/merlabot/"},{"title":"ToDo List","text":"Simple todo-list built with 2 different frameworks - React vs Node.js React Version Built with üèóÔ∏è Client React Redux Redux-thunk styled-components Server (Fake REST API) Express json-server Features üëÄ Basic Create, Read, Update, Delete (CRUD) functionality Node.js Version Built with üèóÔ∏è Express Version Express.js (Node.js) EJS Axios PostgreSQL Features üëÄ Create, Read, Update, Delete (CRUD) functionality Authentication with Sign-up &amp; Login Todo List Saved in database","link":"/2019/12/09/todo-list/"}],"tags":[{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"Axios","slug":"Axios","link":"/tags/Axios/"},{"name":"DOM Javascripts","slug":"DOM-Javascripts","link":"/tags/DOM-Javascripts/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"REST API","slug":"REST-API","link":"/tags/REST-API/"},{"name":"depth-first search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"stack","slug":"stack","link":"/tags/stack/"},{"name":"queue","slug":"queue","link":"/tags/queue/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"hacker rank","slug":"hacker-rank","link":"/tags/hacker-rank/"},{"name":"hash table","slug":"hash-table","link":"/tags/hash-table/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"sliding window","slug":"sliding-window","link":"/tags/sliding-window/"},{"name":"asynchronous function","slug":"asynchronous-function","link":"/tags/asynchronous-function/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"Two Pointers","slug":"Two-Pointers","link":"/tags/Two-Pointers/"}],"categories":[{"name":"Learn Log","slug":"Learn-Log","link":"/categories/Learn-Log/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"Data Structures & Algorithms","slug":"Data-Structures-Algorithms","link":"/categories/Data-Structures-Algorithms/"},{"name":"Array","slug":"Data-Structures-Algorithms/Array","link":"/categories/Data-Structures-Algorithms/Array/"},{"name":"Linked List","slug":"Data-Structures-Algorithms/Linked-List","link":"/categories/Data-Structures-Algorithms/Linked-List/"},{"name":"String","slug":"Data-Structures-Algorithms/String","link":"/categories/Data-Structures-Algorithms/String/"},{"name":"Tree","slug":"Data-Structures-Algorithms/Tree","link":"/categories/Data-Structures-Algorithms/Tree/"},{"name":"Hash Table","slug":"Data-Structures-Algorithms/Hash-Table","link":"/categories/Data-Structures-Algorithms/Hash-Table/"},{"name":"Backtracking","slug":"Data-Structures-Algorithms/Backtracking","link":"/categories/Data-Structures-Algorithms/Backtracking/"},{"name":"Binary","slug":"Data-Structures-Algorithms/Binary","link":"/categories/Data-Structures-Algorithms/Binary/"},{"name":"Recursion","slug":"Data-Structures-Algorithms/Recursion","link":"/categories/Data-Structures-Algorithms/Recursion/"},{"name":"Binary Search","slug":"Data-Structures-Algorithms/Binary-Search","link":"/categories/Data-Structures-Algorithms/Binary-Search/"},{"name":"Sort","slug":"Data-Structures-Algorithms/Sort","link":"/categories/Data-Structures-Algorithms/Sort/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Projects","slug":"Projects","link":"/categories/Projects/"},{"name":"JavaScript","slug":"Programming/JavaScript","link":"/categories/Programming/JavaScript/"}]}